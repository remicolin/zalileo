use hex::ToHex;
// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use methods::{
    PROOF_OF_LOCATION_GUEST_ELF, PROOF_OF_LOCATION_GUEST_ID
};
use risc0_zkvm::{default_prover, ExecutorEnv, Receipt};
use p256::{
    ecdsa::{signature::Signer, Signature, SigningKey, VerifyingKey}, pkcs8::DecodePublicKey, EncodedPoint
};
use rand_core::OsRng;
use hex_literal::hex;
use anyhow::Result;
use bitvec::{field::BitField, vec::BitVec};
use chrono::NaiveDateTime;
use clap::Parser;
use galileo_osnma::{
    galmon::{
        navmon::{
            nav_mon_message::{GalileoInav, Type},
            NavMonMessage,
        },
        transport::WriteTransport,
    },
    types::BitSlice,
    Gst, PublicKey,
};
use tracing_subscriber::fmt::format;
use std::{fs, path::PathBuf};
use nmea_parser::*;
use sha2::{Sha256, Digest};

fn filename_to_gst(filename: &str) -> Result<Gst> {
    let dt = NaiveDateTime::parse_from_str(filename, "%d_%b_%Y_GST_%H_%M_%S.csv")?;
    let t = dt.and_utc().timestamp();
    let gst_epoch_t = 935280000; // 1999-08-22 00:00:00 GST
    let gst_seconds = t - gst_epoch_t;
    const SECS_IN_WEEK: i64 = 24 * 3600 * 7;
    let wn = gst_seconds / SECS_IN_WEEK;
    let tow = gst_seconds - wn * SECS_IN_WEEK;
    Ok(Gst::new(wn.try_into().unwrap(), tow.try_into().unwrap()))
}

fn csv_line_to_pages(line: &str, start_gst: Gst) -> Result<Vec<NavMonMessage>> {
    let mut gst = start_gst;
    let mut fields = line.split(',');
    let wrong_format = || anyhow::anyhow!("CSV has wrong format");
    let svn: u32 = fields.next().ok_or_else(wrong_format)?.parse()?;
    // skip length CSV field
    fields.next().ok_or_else(wrong_format)?;
    let data = hex::decode(fields.next().ok_or_else(wrong_format)?)?;
    const PAGE_SIZE: usize = 240 / 8;
    if data.len() % PAGE_SIZE != 0 {
        return Err(wrong_format());
    }
    let messages = data
        .chunks_exact(PAGE_SIZE)
        .map(|page| {
            let gnss_wn: u32 = gst.wn().into();
            let gnss_tow = gst.tow();
            gst = gst.add_seconds(2);
            let gnss_id = 2;
            let gnss_sv = svn;
            let page = BitSlice::from_slice(page);
            let mut inav_data = BitVec::from_bitslice(&page[2..2 + 112]);
            inav_data.extend_from_bitslice(&page[122..122 + 16]);
            inav_data.force_align();
            inav_data.set_uninitialized(false);
            let contents = inav_data.into_vec();
            let sigid = Some(1);
            let mut reserved1 = BitVec::from_bitslice(&page[120 + 2 + 16..120 + 2 + 16 + 40]);
            reserved1.force_align();
            let reserved1 = Some(reserved1.into_vec());
            let mut reserved2 = BitVec::from_bitslice(&page[240 - 8 - 6..240 - 6]);
            reserved2.force_align();
            let reserved2 = reserved2.into_vec();
            let ssp = Some(u32::from(reserved2[0]));
            let reserved2 = Some(reserved2);
            // Galmon gets 24 bits instead of 22 for SAR
            let mut sar = BitVec::from_bitslice(&page[120 + 2 + 16 + 40..120 + 2 + 16 + 40 + 24]);
            sar.force_align();
            let sar = Some(sar.into_vec());
            // This is only 2 bits as the LSBs of an u8
            let spare = page[120 + 2 + 16 + 40 + 22..120 + 2 + 16 + 40 + 22 + 2].load_be::<u8>();
            let spare = Some(vec![spare]);
            let mut crc = BitVec::from_bitslice(&page[240 - 8 - 6 - 24..240 - 8 - 6]);
            crc.force_align();
            let crc = Some(crc.into_vec());
            let gi = Some(GalileoInav {
                gnss_wn,
                gnss_tow,
                gnss_id,
                gnss_sv,
                contents,
                sigid,
                reserved1,
                reserved2,
                sar,
                spare,
                crc,
                ssp,
            });
            let type_ = Type::GalileoInavType.into();
            let source_id = 0;
            let local_utc_seconds = 0;
            let local_utc_nanoseconds = 0;
            NavMonMessage {
                source_id,
                r#type: type_,
                local_utc_seconds,
                local_utc_nanoseconds,
                gi,
                ..Default::default()
            }
        })
        .collect();
    Ok(messages)
}

pub const GALMON_PACKETS: [u8; 832] = hex!(
    "
    62 65 72 74 00 2a 08 01 10 01 18 cb a3 97 91 06
    20 af ca 8d bb 02 32 18 08 00 10 0a 18 00 20 19
    28 aa 02 31 00 00 00 00 00 00 00 00 40 00 48 00
    62 65 72 74 00 2a 08 01 10 01 18 cb a3 97 91 06
    20 af ca 8d bb 02 32 18 08 00 10 0c 18 00 20 37
    28 d9 01 31 00 00 00 00 00 00 00 00 40 00 48 00
    62 65 72 74 00 2a 08 01 10 01 18 cb a3 97 91 06
    20 af ca 8d bb 02 32 18 08 00 10 0d 18 00 20 1c
    28 85 01 31 00 00 00 00 00 00 00 00 40 00 48 00
    62 65 72 74 00 2a 08 01 10 01 18 cb a3 97 91 06
    20 af ca 8d bb 02 32 18 08 00 10 0f 18 00 20 37
    28 a2 01 31 00 00 00 00 00 00 00 00 40 00 48 00
    62 65 72 74 00 29 08 01 10 01 18 cb a3 97 91 06
    20 af ca 8d bb 02 32 17 08 00 10 11 18 00 20 16
    28 35 31 00 00 00 00 00 00 00 00 40 00 48 00 62
    65 72 74 00 29 08 01 10 01 18 cb a3 97 91 06 20
    af ca 8d bb 02 32 17 08 00 10 13 18 00 20 1f 28
    4d 31 00 00 00 00 00 00 00 00 40 00 48 00 62 65
    72 74 00 2a 08 01 10 01 18 cb a3 97 91 06 20 af
    ca 8d bb 02 32 18 08 00 10 17 18 00 20 20 28 84
    02 31 00 00 00 00 00 00 00 00 40 00 48 00 62 65
    72 74 00 2a 08 01 10 01 18 cb a3 97 91 06 20 af
    ca 8d bb 02 32 18 08 00 10 18 18 00 20 48 28 d6
    02 31 00 00 00 00 00 00 00 00 40 00 48 00 62 65
    72 74 00 2a 08 01 10 01 18 cb a3 97 91 06 20 af
    ca 8d bb 02 32 18 08 00 10 19 18 00 20 11 28 e2
    01 31 00 00 00 00 00 00 00 00 40 00 48 00 62 65
    72 74 00 2a 08 01 10 01 18 cb a3 97 91 06 20 af
    ca 8d bb 02 32 18 08 02 10 01 18 00 20 06 28 e8
    01 31 00 00 00 00 00 00 00 00 40 00 48 00 62 65
    72 74 00 2a 08 01 10 01 18 cb a3 97 91 06 20 af
    ca 8d bb 02 32 18 08 02 10 07 18 00 20 18 28 94
    01 31 00 00 00 00 00 00 00 00 40 00 48 00 62 65
    72 74 00 29 08 01 10 01 18 cb a3 97 91 06 20 af
    ca 8d bb 02 32 17 08 02 10 12 18 00 20 1d 28 53
    31 00 00 00 00 00 00 00 00 40 00 48 00 62 65 72
    74 00 2a 08 01 10 01 18 cb a3 97 91 06 20 af ca
    8d bb 02 32 18 08 02 10 13 18 00 20 33 28 b2 02
    31 00 00 00 00 00 00 00 00 40 00 48 00 62 65 72
    74 00 2a 08 01 10 01 18 cb a3 97 91 06 20 af ca
    8d bb 02 32 18 08 02 10 15 18 00 20 35 28 eb 01
    31 00 00 00 00 00 00 00 00 40 00 48 00 62 65 72
    74 00 29 08 01 10 01 18 cb a3 97 91 06 20 af ca
    8d bb 02 32 17 08 02 10 1b 18 00 20 45 28 2a 31
    00 00 00 00 00 00 00 00 40 00 48 00 62 65 72 74
    00 29 08 01 10 01 18 cb a3 97 91 06 20 af ca 8d
    bb 02 32 17 08 02 10 1e 18 00 20 0e 28 32 31 00
    00 00 00 00 00 00 00 40 00 48 00 62 65 72 74 00
    3f 08 01 10 02 18 cb a3 97 91 06 20 af ca 8d bb
    02 42 2d 09 ec 51 b8 de f3 76 52 41 11 8f c2 f5
    28 96 19 13 c1 19 33 33 33 13 59 80 4f 41 21 e1
    7a 14 ae 47 21 30 40 29 00 00 00 00 00 00 00 00"
);

pub fn convert(data: &[u32; 8]) -> [u8; 32] {
    let mut res = [0; 32];
    for i in 0..8 {
        res[4 * i..4 * (i + 1)].copy_from_slice(&data[i].to_le_bytes());
    }
    res
}

fn main() {
    // Initialize tracing. In order to view logs, run `RUST_LOG=info cargo run`
    tracing_subscriber::fmt()
        .with_env_filter(tracing_subscriber::filter::EnvFilter::from_default_env())
        .init();

    // Generate a random secp256r1 keypair and sign the message.
    /*let signing_key = SigningKey::random(&mut OsRng); // Serialize with `::to_bytes()`
    let message = b"This is a message that will be signed, and verified within the zkVM";
    let signature: Signature = signing_key.sign(message);*/

    // Run signature verified in the zkVM guest and get the resulting receipt.
    //let receipt = prove_ecdsa_verification(signing_key.verifying_key(), message, &signature);

    //let input = GALMON_PACKETS;

    /*let filepath = PathBuf::from("../Test_vectors/osnma_test_vectors/configuration_1/16_AUG_2023_GST_05_00_01.csv");
    let filename = "16_AUG_2023_GST_05_00_01.csv";
    
    let start_gst = filename_to_gst(filename).unwrap();

    let csv = fs::read_to_string(filepath).unwrap();
    let mut csv = csv.lines();
    // discard csv header
    csv.next().unwrap();
    let mut pages = Vec::new();
    for line in csv {
        pages.push(csv_line_to_pages(line, start_gst).unwrap());
    }
    
    let mut input = Vec::new();
    let mut write_transport = WriteTransport::new(&mut input);

    let mut page_num = 0;
    let mut has_pages = true;
    while has_pages {
        has_pages = false;
        for svn_pages in &pages {
            if let Some(page) = svn_pages.get(page_num) {
                has_pages = true;
                write_transport.write_packet(page).unwrap();
            }
        }
        page_num += 1;
    }*/

    let path = PathBuf::from(format!("{}/../gnss_log_2024_08_11_15_26_14.nmea", env!("CARGO_MANIFEST_DIR")));
    let file = fs::read_to_string(&path).unwrap();

    let pubkey = String::from("1143c50c457002ac5273549e633e59172d13a4f7d8747fb958c4ff4f4e668ad36706a43bbb8ff73b67eb0ff6d478d58aa018ae9c9d199b3e991cf6333ad51bf6");
    let hex_sig = "7973f147720c39018f25ef5f2431f31faddd474bbdce266a31ea278f8335434dcbaa10496a4f72e8c16e8a467c6b9dc406530fc8330c3f72b44add56957a5bf8";
    let sig_bytes = hex::decode(hex_sig).unwrap();
    let signature: Signature = Signature::from_bytes(sig_bytes.as_slice().into()).unwrap();

    println!("Signature: {:?}", signature);
    println!("Hex Signature: {:?}", signature.to_string());

    let input = (pubkey, file, signature);    

    let env = ExecutorEnv::builder()
        .write(&input)
        .unwrap()
        .build()
        .unwrap();

    // Obtain the default prover.
    let prover = default_prover();

    // Produce a receipt by proving the specified ELF binary.
    let receipt = prover.prove(env, PROOF_OF_LOCATION_GUEST_ELF).unwrap().receipt;

    // Verify the receipt and then access the journal.
    receipt.verify(PROOF_OF_LOCATION_GUEST_ID).unwrap();
    let len: u32 =
        receipt.journal.decode().unwrap();

    /*let serialized = bincode::serialize(&receipt).unwrap();
    std::fs::write("proof", serialized).expect("Failed to write proof file");

    std::fs::write("file_id", convert(&PROOF_OF_LOCATION_GUEST_ID))
        .expect("Failed to write id file");

    std::fs::write("public_inputs", receipt.journal.bytes)
        .expect("Failed to write pub_input file");*/

    /*let proof = &receipt.inner.succinct().unwrap().seal;
    let proof_bytes = proof.iter().flat_map(|x| x.to_le_bytes().to_vec()).collect::<Vec<u8>>();
    fs::write("proof", proof_bytes).unwrap();*/
}
